#!/bin/bash

# Determine the type of Kubernetes that is being used and set variables
if [[ -f '/usr/bin/kubectl' ]]; then
    echo "-- Node is running k8s --"
    kubecmd="/usr/bin/kubectl"
    kubeconfig="/etc/kubernetes/admin.conf"
elif [[ -f '/var/lib/rancher/rke2/bin/kubectl' ]]; then
    echo "-- Node is running RKE2 --"
    kubecmd="/var/lib/rancher/rke2/bin/kubectl"
    kubeconfig="/etc/rancher/rke2/rke2.yaml"
else
    echo "-- Unable to determine Kubernetes type --"
    exit 1
fi

# Define kubectl command in a variable
kubectl="$kubecmd --kubeconfig=$kubeconfig"

# Display the help text
show_help() {
cat <<HELP
Usage: k8s-mgmt [option]

Options:
  -h    Show this help text
  -n    Set the node to interact with
  -t    Set the workflow type (cordon | drain | uncordon)

HELP
}

# Read in arguments to set API options
while getopts "hn:t:" option; do
    case "$option" in
        h) show_help;;
        n) node_name="$OPTARG" ;;
        t) workflow_type="$OPTARG" ;;
        *) show_help;;
    esac
done

main() {
    # Mandatory checks
    check_status "verify_api_connectivity"
    check_status "verify_controlplane"
    verify_node_exists

    # Execute workflow specified by -t argument
    if [[ "$workflow_type" == 'cordon' ]]; then
        cordon_workflow
    elif [[ "$workflow_type" == 'drain' ]]; then
        drain_workflow
    elif [[ "$workflow_type" == 'uncordon' ]]; then
        uncordon_workflow
    else
        echo "-- Incorrect workflow type $workflow_type specified. Exiting script --"
        exit 1
    fi

}

verify_node_exists() {
    # Verify that the $node_name exists in the cluster
    if ! $kubectl get node "$node_name" >/dev/null; then
        echo "-- The node $node_name was not found in the cluster. Exiting script --"
        exit 1
    fi
}

cordon_workflow() {
    # Cordon the node
    $kubectl cordon "$node_name"
    sleep 2

    # Wait for node to be cordoned
    check_status "cordon"
}

drain_workflow() {
    # Drain and cordon the node (drain does both)
    # Set timeout to 5 minutes - Exit unsuccessfully if this timeout is exceeded
    if ! $kubectl drain "$node_name" --ignore-daemonsets --delete-emptydir-data --timeout=300s; then
        echo "-- The drain of $node_name did not complete within 5 minutes. Review output for issues --"
        exit 1
    fi
    sleep 2

    # Wait for node to be cordoned
    check_status "drain"
}

uncordon_workflow() {
    # Verify that the node is ready
    check_status "verify_node_ready"

    # Uncordon the node
    $kubectl uncordon "$node_name"
    sleep 2

    # Verify the node was uncordoned
    check_status "uncordon"
}

check_status() {
    # Determine workflow test based on first argument
    workflow_test="$1"

    ##
    # Define variables for the various checks
    ##

    case "$workflow_test" in
        verify_api_connectivity)
            check_command="$kubectl get nodes | grep 'control-plane' >/dev/null"
            test_type="errorlevel"
            success_message="The Kubernetes API is reachable, proceeding"
            fail_message="The Kubernetes API is unreachable. Exiting script"
            ;;
            
        verify_node_ready)
            check_command="! $kubectl get node $node_name | grep -i -E '(NotReady|Unknown)'"
            test_type="errorlevel"
            desired_result="true"
            success_message="Node $node_name is ready"
            fail_message="Node $node_name did not become ready in time"
            ;;
            
        verify_controlplane)
            check_command="! $kubectl get nodes | grep -i -E '(control-plane|etcd|master)' | grep -i -E '(NotReady|Unknown)'"
            test_type="errorlevel"
            success_message="All control plane nodes are in a Ready state, proceeding"
            fail_message="One or more control plane nodes is in a NotReady or Unknown state. Exiting script"
            ;;
    
        cordon|drain|uncordon)
            check_command="$kubectl get node $node_name --output=jsonpath='{.spec.unschedulable}'"
            test_type="output"
    
            case "$workflow_test" in
                cordon)
                    desired_result="true"
                    success_message="Node $node_name cordoned successfully"
                    fail_message="Node $node_name did not cordon successfully"
                    ;;
                drain)
                    desired_result="true"
                    success_message="Node $node_name drained and cordoned successfully"
                    fail_message="Node $node_name did not drain and cordon successfully"
                    ;;
                uncordon)
                    desired_result=""
                    success_message="Node $node_name uncordoned successfully"
                    fail_message="Node $node_name did not uncordon successfully"
                    ;;
            esac
            ;;
            
        *)
            echo "-- Incorrect workflow test '$workflow_test' specified. Exiting script --"
            exit 1
            ;;
    esac

    # Default test_success to 0
    test_success="0"

    for _ in {1..20}; do
        if [[ "$test_type" == 'errorlevel' ]]; then
            if eval "$check_command"; then
                # If the command succeeded, set success to 1 and exit the loop
                test_success="1"
                break
            fi
        
        elif [[ "$test_type" == 'output' ]]; then
            command_result=""
            command_result="$(eval "$check_command")"
            if [[ "$?" == 0 && "${command_result,,}" == "$desired_result" ]]; then
                # If the command succeeded and the desired result was achieved, set success to 1 and exit the loop
                test_success="1"
                break
            fi

        else
            echo "-- Undetermined test_type of $test_type. Exiting script --"
            exit 1
        fi

        # Wait a little more time
        sleep 10
    done
    
    # Print the appropriate message for the check and exit with errorlevel 1 on failure
    if [[ "$test_success" == 1 ]]; then
        echo "-- $success_message --"
    else
        echo "-- $fail_message --"
        exit 1
    fi
}

main
