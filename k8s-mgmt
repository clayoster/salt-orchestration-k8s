#!/bin/bash

# Determine the type of Kubernetes that is being used and set variables
if [[ -f '/usr/bin/kubectl' ]]; then
    echo "-- Node is running k8s --"
    kubecmd="/usr/bin/kubectl"
    kubeconfig="/etc/kubernetes/admin.conf"
elif [[ -f '/var/lib/rancher/rke2/bin/kubectl' ]]; then
    echo "-- Node is running RKE2 --"
    kubecmd="/var/lib/rancher/rke2/bin/kubectl"
    kubeconfig="/etc/rancher/rke2/rke2.yaml"
else
    echo "-- Unable to determine Kubernetes type --"
    exit 1
fi

# Define kubectl command in a variable
kubectl="$kubecmd --kubeconfig=$kubeconfig"

# Display the help text
show_help() {
cat <<HELP
Usage: k8s-mgmt [option]

Options:
  -h    Show this help text
  -n    Set the node to interact with
  -t    Set the workflow type ( precheck | precheck_clean | cordon | drain | uncordon )

HELP
}

# Read in arguments to set API options
while getopts "hn:t:" option; do
    case "$option" in
        h) show_help;;
        n) node_name="$OPTARG" ;;
        t) workflow_type="$OPTARG" ;;
        *) show_help;;
    esac
done

# Test input arguments
if [[ -z "$workflow_type" ]]; then
    echo "-- A workflow type must be specified with the -t argument. Exiting script --"
    exit 1
elif [[ "$workflow_type" =~ (cordon|drain|uncordon) && -z "$node_name" ]]; then
    echo "-- A node name must be specified with the -n argument for the $workflow_type workflow. Exiting script --"
    exit 1
fi

# Confirm jq is installed as functions below depend upon it
if ! command -v jq &>/dev/null; then
    echo "-- jq is not installed; Exiting script --"
    exit 1
fi

main() {
    # Mandatory checks
    check_status "verify_api_connectivity"
    check_status "verify_controlplane"

    # Execute workflow specified by -t argument
    if [[ "$workflow_type" == 'precheck' ]]; then
        precheck_workflow
    elif [[ "$workflow_type" == 'precheck_clean' ]]; then
        precheck_workflow clean
    elif [[ "$workflow_type" == 'cordon' ]]; then
        verify_node_exists
        cordon_workflow
    elif [[ "$workflow_type" == 'drain' ]]; then
        verify_node_exists
        drain_workflow
    elif [[ "$workflow_type" == 'uncordon' ]]; then
        verify_node_exists
        uncordon_workflow
    else
        echo "-- Incorrect workflow type $workflow_type specified. Exiting script --"
        exit 1
    fi

}

precheck_workflow() {
    # Run the precheck workflow to identify pods without controllers
    # If 'clean' is passed as the first argument, delete any pods without controllers that are found
    echo "-- Performing precheck for pods without controllers --"
    pod_list="$($kubectl get pods --all-namespaces -o json | \
        jq -r '.items[]
            | select(.metadata.ownerReferences == null)
            | [.kind, .metadata.namespace, .metadata.name, .spec.nodeName] | @tsv')"
    
    if [[ -z "$pod_list" ]]; then
        echo "-- No pods without controllers were found --"
    else
        echo "-- The following pods without controllers were found --"
        echo "-- Nodes may fail to drain if these pods are not removed --"
        {
            echo -e "KIND\tNAMESPACE\tNAME\tNODE"
            echo -e "$pod_list"
        } | column -t -s $'\t'

        # If 'clean' is specified, delete the pods without controllers
        if [[ "$1" == 'clean' ]]; then
            echo "-- Removing pods without controllers --"
            while read -r kind namespace name node; do
                echo "-- Deleting pod $name in namespace $namespace on node $node --"
                $kubectl delete pod "$name" -n "$namespace" --grace-period=30 --timeout=1m

                if [[ "$?" != 0 ]]; then
                    echo "-- The pod $name in namespace $namespace on node $node did not delete successfully --"
                    pod_delete_error="1"
                else
                    echo "-- The pod $name in namespace $namespace on node $node deleted successfully --"
                fi
            done <<< "$pod_list"
            
            # Check if any pods failed to delete and set an appropriate errorlevel
            if [[ "$pod_delete_error" == 1 ]]; then
                echo "-- One or more pods without controllers did not delete successfully. Review output for issues --"
                exit 1
            else
                echo "-- All pods without controllers deleted successfully --"
            fi
        fi
    fi
}

verify_node_exists() {
    # Verify that the $node_name exists in the cluster
    if ! $kubectl get node "$node_name" >/dev/null; then
        echo "-- The node $node_name was not found in the cluster. Exiting script --"
        exit 1
    fi
}

cordon_workflow() {
    # Cordon the node
    $kubectl cordon "$node_name"
    sleep 2

    # Wait for node to be cordoned
    check_status "cordon"
}

drain_workflow() {
    # Drain and cordon the node (drain does both)
    # Set timeout to 5 minutes - Exit unsuccessfully if this timeout is exceeded
    if ! $kubectl drain "$node_name" --ignore-daemonsets --delete-emptydir-data --timeout=300s; then
        echo "-- The drain of $node_name did not complete within 5 minutes. Review output for issues --"
        exit 1
    fi
    sleep 2

    # Wait for node to be cordoned
    check_status "drain"
}

uncordon_workflow() {
    # Verify that the node is ready
    check_status "verify_node_ready"

    # Uncordon the node
    $kubectl uncordon "$node_name"
    sleep 2

    # Verify the node was uncordoned
    check_status "uncordon"
}

check_status() {
    # Determine workflow test based on first argument
    workflow_test="$1"

    ##
    # Define variables for the various checks
    ##

    case "$workflow_test" in
        verify_api_connectivity)
            check_command="$kubectl get nodes | grep 'control-plane' >/dev/null"
            test_type="errorlevel"
            success_message="The Kubernetes API is reachable, proceeding"
            fail_message="The Kubernetes API is unreachable. Exiting script"
            ;;
            
        verify_node_ready)
            check_command="! $kubectl get node $node_name | grep -i -E '(NotReady|Unknown)'"
            test_type="errorlevel"
            desired_result="true"
            success_message="Node $node_name is ready"
            fail_message="Node $node_name did not become ready in time"
            ;;
            
        verify_controlplane)
            check_command="! $kubectl get nodes | grep -i -E '(control-plane|etcd|master)' | grep -i -E '(NotReady|Unknown)'"
            test_type="errorlevel"
            success_message="All control plane nodes are in a Ready state, proceeding"
            fail_message="One or more control plane nodes is in a NotReady or Unknown state. Exiting script"
            ;;
    
        cordon|drain|uncordon)
            check_command="$kubectl get node $node_name --output=jsonpath='{.spec.unschedulable}'"
            test_type="output"
    
            case "$workflow_test" in
                cordon)
                    desired_result="true"
                    success_message="Node $node_name cordoned successfully"
                    fail_message="Node $node_name did not cordon successfully"
                    ;;
                drain)
                    desired_result="true"
                    success_message="Node $node_name drained and cordoned successfully"
                    fail_message="Node $node_name did not drain and cordon successfully"
                    ;;
                uncordon)
                    desired_result=""
                    success_message="Node $node_name uncordoned successfully"
                    fail_message="Node $node_name did not uncordon successfully"
                    ;;
            esac
            ;;
            
        *)
            echo "-- Incorrect workflow test '$workflow_test' specified. Exiting script --"
            exit 1
            ;;
    esac

    # Default test_success to 0
    test_success="0"

    for _ in {1..20}; do
        if [[ "$test_type" == 'errorlevel' ]]; then
            if eval "$check_command"; then
                # If the command succeeded, set success to 1 and exit the loop
                test_success="1"
                break
            fi
        
        elif [[ "$test_type" == 'output' ]]; then
            command_result=""
            command_result="$(eval "$check_command")"
            if [[ "$?" == 0 && "${command_result,,}" == "$desired_result" ]]; then
                # If the command succeeded and the desired result was achieved, set success to 1 and exit the loop
                test_success="1"
                break
            fi

        else
            echo "-- Undetermined test_type of $test_type. Exiting script --"
            exit 1
        fi

        # Wait a little more time
        sleep 10
    done
    
    # Print the appropriate message for the check and exit with errorlevel 1 on failure
    if [[ "$test_success" == 1 ]]; then
        echo "-- $success_message --"
    else
        echo "-- $fail_message --"
        exit 1
    fi
}

main
